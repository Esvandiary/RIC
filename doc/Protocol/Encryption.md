# Encryption schemes used in RIC

There are various encryption and hashing schemes involved in the RIC system.


## Transport security: TLS

RIC connections use WebSockets, and the spec mandates that all live servers use connections encapsulated by TLS (using the WebSocket Secure URI scheme `wss://`). Server administrators may choose to configure the web server hosting the RIC server with any valid certificate of their choice, but it is recommended to use a certificate trusted by major OS certificate stores, such as those generated by [Let's Encrypt](https://letsencrypt.org).


## Public Key Encryption

RIC servers and users are identified by a public/private RSA key pair. Server keys are stored on the server, whereas users' keys are stored on their home server. In normal operation, users' private keys are never transmitted from their home server; all operations requiring use of the private key are performed locally and their results transmitted back to the client from which the user requested them.

RIC uses a naming scheme of `<System>-<Hash>-<EncryptionPadding>-<SignaturePadding>` to concisely specify the public key encryption scheme in use.

The only currently supported scheme is `rsa-sha256-oaepsha256-pkcs1`, which means:
* The [RSA cryptosystem](<https://en.wikipedia.org/wiki/RSA_(cryptosystem)>)
* Using the [SHA-256](https://en.wikipedia.org/wiki/SHA-2) hash
* Padding encryption/decryption operations using the [OAEP](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding) standard (RSAES-OEAP) with the SHA-256 hash algorithm
* Padding signing operations according to the [PKCS #1](https://en.wikipedia.org/wiki/PKCS_1) v1.5 standard (RSAES-PKCS1-V1_5)


## Hashing

The storing of passwords and other sensitive details is an implementation detail for servers and clients, and is not mandated by the RIC specification. However, the following is a recommended path for password storage, as implemented in the Eric reference system.

Eric uses the [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) key derivation algorithm with 10000 iterations, generating a 256-bit hash (taking in a 256-bit salt alongside the password). It uses the [HMAC](https://en.wikipedia.org/wiki/HMAC) algorithm with a [SHA-256](https://en.wikipedia.org/wiki/SHA-2) hash.


## Password transit

There are times when passwords must inevitably be sent over the wire (e.g. for registration or login requests); in this case, the TLS layer mandated by the spec gives us some level of security. However, we can also provide additional security in this scenario.

Valid formats for transmitting passwords:
* `plaintext`
  * The password data is sent in plaintext as a UTF-8 encoded string
  * This is the simplest format, but means the TLS encapsulation is the only mechanism protecting the data
  * This format is mandatory for endpoints to implement
* `rsa-base64`
  * The password's UTF-8 bytes are encrypted using the receiving endpoint's public key and sent [Base64](https://en.wikipedia.org/wiki/Base64) encoded
  * This is more secure since it requires the receiving endpoint's private key to decrypt the password data
  * This format is mandatory for endpoints to implement, and must be preferred where possible